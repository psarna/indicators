<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Financial Z-Score Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-adapter-moment/1.0.1/chartjs-adapter-moment.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gauge.js/1.3.7/gauge.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .chart-container {
            position: relative;
            height: 400px;
            margin-bottom: 30px;
        }
        .gauge-container {
            width: 300px;
            height: 30px;
            margin: 0 auto;
            position: relative;
        }
        .gauge-value {
            position: absolute;
            bottom: 0;
            width: 100%;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
        }
        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
        }
        .stat-box {
            background-color: #f0f0f0;
            padding: 15px;
            border-radius: 5px;
            width: 22%;
            text-align: center;
        }
        .stat-box h3 {
            margin-top: 0;
            color: #555;
        }
        .stat-box p {
            font-size: 20px;
            font-weight: bold;
            margin: 5px 0 0 0;
        }
        h1, h2 {
            color: #333;
            text-align: center;
        }
        .loading {
            text-align: center;
            padding: 50px;
            font-size: 20px;
            color: #666;
        }
        .error {
            background-color: #ffeeee;
            color: #cc0000;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            display: none;
        }
        .info {
            background-color: #f0f0ff;
            color: #333;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .symbol-info {
            text-align: center;
            font-size: 18px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        .tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 15px;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
            background-color: #f5f5f5;
        }
        .tab.active {
            background-color: white;
            border-color: #ddd;
            font-weight: bold;
        }
        #script-editor-container {
            display: none;
            margin-top: 30px;
        }
        .editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .editor-title {
            font-size: 18px;
            font-weight: bold;
        }
        #script-editor {
            width: 100%;
            height: 300px;
            font-family: monospace;
            padding: 10px;
            border: 1px solid #e2e8f0;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        .editor-controls {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin-top: 10px;
        }
        .editor-controls input {
            flex: 1;
            padding: 8px;
            border: 1px solid #e2e8f0;
            border-radius: 5px;
        }
        .button {
            background-color: #4299e1;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .button:hover {
            background-color: #3182ce;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Enhanced Financial Z-Score Visualizer</h1>
        
        <div id="symbol-info" class="symbol-info">BTC/USD</div>
        
        <div id="info" class="info">
            Using default BTC/USD price data. You can provide a custom data source by adding ?script=URL to the page URL.
        </div>
        
        <div id="errorMessage" class="error"></div>
        
        <div id="loading" class="loading">
            Loading financial data...
        </div>
        
        <div id="content" style="display:none;">
            <div class="stats">
                <div class="stat-box">
                    <h3>Mean</h3>
                    <p id="mean">-</p>
                </div>
                <div class="stat-box">
                    <h3>Std Dev</h3>
                    <p id="stdDev">-</p>
                </div>
                <div class="stat-box">
                    <h3>Current Value</h3>
                    <p id="current-value">-</p>
                </div>
                <div class="stat-box">
                    <h3>Z-Score</h3>
                    <p id="zScore">-</p>
                </div>
            </div>
            
            <div class="tabs">
                <div class="tab active" onclick="showChart('timelineChart')">Timeline with Z-Score</div>
                <div class="tab" onclick="showChart('distributionChart')">Normal Distribution</div>
            </div>
            
            <div id="timelineChart" class="chart-container">
                <canvas id="timeSeriesChart"></canvas>
            </div>
            
            <div id="distributionChart" class="chart-container" style="display:none;">
                <canvas id="distChart"></canvas>
            </div>
            
            <div class="gauge-container">
                <div class="gauge-value" id="gaugeValue">-</div>
            </div>
            <div id="script-editor-container" class="card">
                <div class="card-header">
                    <div class="editor-title">Script Editor</div>
                </div>
                <div class="card-body">
                    <p>Edit the script below to fetch and process custom data. The script should be an async function that returns data.</p>
                    <textarea id="script-editor"></textarea>
                    <div class="editor-controls">
                        <input id="symbol-input" type="text" placeholder="Symbol or Data Name">
                        <button class="button" onclick="runScript()">Run Script</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
// Function to parse URL parameters
function getParameterByName(name, url = window.location.href) {
    name = name.replace(/[\[\]]/g, '\\$&');
    var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
        results = regex.exec(url);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, ' '));
}

// Default BTC/USD data endpoint
const DEFAULT_BTC_ENDPOINT = "https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=30&interval=daily";

// Default script that fetches BTC data
const DEFAULT_SCRIPT = `async function() {
    const response = await fetch("${DEFAULT_BTC_ENDPOINT}", {
        mode: 'cors',
        headers: {
            'Accept': 'application/json'
        }
    });
    
    if (!response.ok) {
        throw new Error(\`HTTP error! Status: \${response.status}\`);
    }
    
    return await response.json();
}`;

// Base64 encode the default script
function encodeBase64(str) {
    return btoa(str);
}

// Function to safely decode base64
function decodeBase64(str) {
    try {
        return atob(str);
    } catch (e) {
        throw new Error('Invalid base64 encoding');
    }
}

// Getting the script parameter
let scriptParam = getParameterByName('script');

// Chart instances
let timeSeriesChart, distributionChart;

// Function to switch between chart views
function showChart(chartId) {
    document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
    document.querySelectorAll('.chart-container').forEach(container => container.style.display = 'none');
    
    if (chartId === 'timelineChart') {
        document.querySelector('.tab:first-child').classList.add('active');
        document.getElementById('timelineChart').style.display = 'block';
    } else {
        document.querySelector('.tab:last-child').classList.add('active');
        document.getElementById('distributionChart').style.display = 'block';
    }
}

// Function to run the script and update the URL
function runScript() {
    const scriptContent = document.getElementById('script-editor').value;
    const encodedScript = encodeBase64(scriptContent);
    const symbol = document.getElementById('symbol-input').value || "Custom Data";
    
    // Update URL with the new script and symbol
    const newUrl = window.location.pathname + 
                  `?script=${encodedScript}&symbol=${encodeURIComponent(symbol)}`;
    
    window.location.href = newUrl;
}

// Main function to initialize everything once data is loaded
async function initialize() {
    try {
        // If no script parameter is provided, use the default script
        if (!scriptParam) {
            scriptParam = encodeBase64(DEFAULT_SCRIPT);
            document.getElementById('info').style.display = 'block';
            // Don't redirect, just use the default script parameter
        } else {
            document.getElementById('info').style.display = 'none';
        }
        
        // Decode script parameter and fill the script editor
        const decodedScript = decodeBase64(scriptParam);
        document.getElementById('script-editor').value = decodedScript;
        
        // Execute the script to get data (unified path for both default and custom)
        try {
            const scriptFunction = new Function('return ' + decodedScript)();
            const data = await scriptFunction();
            
            // Update the symbol info if provided
            const urlSymbol = getParameterByName('symbol') || "Bitcoin/USD";
            document.getElementById('symbol-info').textContent = urlSymbol;
            document.getElementById('symbol-input').value = urlSymbol;
            
            // Process the data
            processData(data);
            
        } catch (error) {
            throw new Error(`Error executing script: ${error.message}`);
        }
        
    } catch (error) {
        document.getElementById('loading').style.display = 'none';
        document.getElementById('errorMessage').style.display = 'block';
        document.getElementById('errorMessage').textContent = `Error: ${error.message}`;
        console.error("Error:", error);
    }
}

function processData(data) {
    // Extract prices and timestamps based on data structure
    let prices = [];
    let timestamps = [];
    
    // Try to determine the data format and extract values
    if (data.prices && Array.isArray(data.prices)) {
        // CoinGecko format
        timestamps = data.prices.map(pair => new Date(pair[0]));
        prices = data.prices.map(pair => pair[1]);
    } else if (data.chart && data.chart.result && data.chart.result[0] && data.chart.result[0].indicators) {
        // Yahoo Finance format
        prices = data.chart.result[0].indicators.quote[0].close || [];
        timestamps = data.chart.result[0].timestamp.map(ts => new Date(ts * 1000));
        // Filter out null/undefined values
        const validData = prices.map((price, i) => ({price, timestamp: timestamps[i]}))
            .filter(item => item.price !== null && item.price !== undefined);
        prices = validData.map(item => item.price);
        timestamps = validData.map(item => item.timestamp);
    } else if (Array.isArray(data)) {
        // Simple array of prices
        prices = data;
        timestamps = Array.from({length: data.length}, (_, i) => new Date(Date.now() - (data.length - i - 1) * 24 * 60 * 60 * 1000));
    } else {
        // Try to find prices in the data structure
        for (const key in data) {
            if (Array.isArray(data[key]) && data[key].length > 0 && typeof data[key][0] === 'number') {
                prices = data[key];
                timestamps = Array.from({length: prices.length}, (_, i) => new Date(Date.now() - (prices.length - i - 1) * 24 * 60 * 60 * 1000));
                break;
            } else if (Array.isArray(data[key]) && data[key].length > 0 && Array.isArray(data[key][0]) && data[key][0].length >= 2) {
                // Try to handle [timestamp, price] format
                timestamps = data[key].map(pair => new Date(pair[0]));
                prices = data[key].map(pair => pair[1]);
                break;
            }
        }
    }
    
    if (prices.length === 0) {
        throw new Error("No valid price data found in the provided JSON.");
    }
    
    // Calculate statistics
    calculateStats(prices, timestamps);
}

function calculateStats(prices, timestamps) {
    // Calculate statistics
    const min = Math.min(...prices);
    const max = Math.max(...prices);
    const mean = prices.reduce((sum, price) => sum + price, 0) / prices.length;
    
    // Standard deviation calculation
    const squaredDifferences = prices.map(price => Math.pow(price - mean, 2));
    const variance = squaredDifferences.reduce((sum, val) => sum + val, 0) / prices.length;
    const stdDev = Math.sqrt(variance);
    
    // Get current value (last price in the array)
    const currentValue = prices[prices.length - 1];
    
    // Calculate z-score
    const zScore = (currentValue - mean) / stdDev;
    
    // Update the UI with calculated values
    document.getElementById('mean').textContent = formatNumber(mean);
    document.getElementById('stdDev').textContent = formatNumber(stdDev);
    document.getElementById('current-value').textContent = formatNumber(currentValue);
    document.getElementById('zScore').textContent = zScore.toFixed(2);
    
    // Create the timeline chart
    createTimeSeriesChart(prices, timestamps, mean, stdDev);
    
    // Create the distribution chart
    createDistributionChart(mean, stdDev, currentValue);
    
    // Create the gauge chart for z-score
    createZScoreGauge(zScore);
    
    // Hide loading and show content
    document.getElementById('loading').style.display = 'none';
    document.getElementById('content').style.display = 'block';
    document.getElementById('script-editor-container').style.display = 'block';
}

function formatNumber(num) {
    // Format large numbers with commas and two decimal places
    return num.toLocaleString(undefined, {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    });
}

function createTimeSeriesChart(prices, timestamps, mean, stdDev) {
    const ctx = document.getElementById('timeSeriesChart').getContext('2d');
    
    // Calculate z-scores for all prices
    const zScores = prices.map(price => (price - mean) / stdDev);
    
    // Create shaded z-score regions
    const zScoreRegions = [
        { z: -3, color: 'rgba(100, 100, 255, 0.2)' }, // Dark blue (highest)
        { z: -2, color: 'rgba(150, 150, 255, 0.2)' }, // Medium blue
        { z: -1, color: 'rgba(200, 200, 255, 0.2)' }, // Light blue
        { z: 0, color: 'rgba(230, 230, 230, 0.2)' },  // Neutral
        { z: 1, color: 'rgba(255, 200, 200, 0.2)' },  // Light red
        { z: 2, color: 'rgba(255, 150, 150, 0.2)' },  // Medium red
        { z: 3, color: 'rgba(255, 100, 100, 0.2)' }   // Dark red (lowest)
    ];
    
    // Calculate price levels for each z-score
    const zScorePrices = zScoreRegions.map(region => mean + (region.z * stdDev));
    
    // Create datasets for z-score lines
    const zScoreDatasets = zScoreRegions.map((region, index) => {
        return {
            label: `Z = ${region.z}`,
            data: Array(timestamps.length).fill(zScorePrices[index]),
            borderColor: region.color.replace('0.2', '1'),
            borderWidth: 1,
            borderDash: [5, 5],
            pointRadius: 0,
            fill: false
        };
    });
    
    // Create the time series chart
    timeSeriesChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: timestamps,
            datasets: [
                {
                    label: 'Price',
                    data: prices,
                    borderColor: 'rgba(54, 162, 235, 1)',
                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1
                },
                {
                    label: 'Mean',
                    data: Array(timestamps.length).fill(mean),
                    borderColor: 'rgba(75, 192, 192, 1)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    fill: false
                },
                ...zScoreDatasets
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'time',
                    time: {
                        unit: 'day',
                        displayFormats: {
                            day: 'MMM dd'
                        }
                    },
                    title: {
                        display: true,
                        text: 'Date'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Price'
                    }
                },
                y1: {
                    position: 'right',
                    title: {
                        display: true,
                        text: 'Z-Score'
                    },
                    min: -3.5,
                    max: 3.5,
                    grid: {
                        drawOnChartArea: false
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            if (context.dataset.label === 'Price') {
                                const value = context.parsed.y;
                                const z = (value - mean) / stdDev;
                                return [`Price: ${formatNumber(value)}`, `Z-Score: ${z.toFixed(2)}`];
                            } else {
                                return context.dataset.label;
                            }
                        }
                    }
                },
                legend: {
                    display: true
                }
            }
        },
        plugins: [{
            id: 'backgroundColoring',
            beforeDraw: (chart) => {
                const {ctx, chartArea, scales} = chart;
                const {left, right, top, bottom} = chartArea;
                
                // Draw colored background areas based on z-scores
                for (let i = 0; i < zScoreRegions.length - 1; i++) {
                    const y1 = scales.y.getPixelForValue(zScorePrices[i]);
                    const y2 = scales.y.getPixelForValue(zScorePrices[i + 1]);
                    
                    ctx.fillStyle = zScoreRegions[i].color;
                    ctx.fillRect(left, y1, right - left, y2 - y1);
                }
            }
        }]
    });
}

function createDistributionChart(mean, stdDev, currentValue) {
    const ctx = document.getElementById('distChart').getContext('2d');
    
    // Generate points for the normal distribution curve
    const points = [];
    const labels = [];
    const backgroundColors = [];
    
    // Define z-score range for visualization
    const minZ = -3;
    const maxZ = 3;
    const step = 0.1;
    
    for (let z = minZ; z <= maxZ; z += step) {
        const x = mean + (z * stdDev);
        const y = Math.exp(-0.5 * z * z) / (stdDev * Math.sqrt(2 * Math.PI));
        
        points.push({x, y});
        labels.push(x.toFixed(2));
        
        // Map z-score to color (INVERTED: -3 is higher than mean, +3 is lower than mean)
        const colorValue = -z; // Invert as per requirement
        
        if (colorValue < -2) {
            backgroundColors.push('rgba(255, 100, 100, 0.3)'); // Dark red (low)
        } else if (colorValue < -1) {
            backgroundColors.push('rgba(255, 150, 150, 0.3)'); // Medium red
        } else if (colorValue < 0) {
            backgroundColors.push('rgba(255, 200, 200, 0.3)'); // Light red
        } else if (colorValue < 1) {
            backgroundColors.push('rgba(200, 200, 255, 0.3)'); // Light blue
        } else if (colorValue < 2) {
            backgroundColors.push('rgba(150, 150, 255, 0.3)'); // Medium blue
        } else {
            backgroundColors.push('rgba(100, 100, 255, 0.3)'); // Dark blue (high)
        }
    }
    
    // Create the distribution chart
    distributionChart = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [{
                label: 'Normal Distribution',
                data: points,
                borderColor: 'rgba(75, 85, 99, 1)',
                backgroundColor: 'rgba(75, 85, 99, 0.1)',
                borderWidth: 2,
                pointRadius: 0,
                fill: false,
                tension: 0.4
            }, {
                label: 'Current Value',
                data: [{x: currentValue, y: 0}, {
                    x: currentValue, 
                    y: Math.exp(-0.5 * Math.pow((currentValue - mean) / stdDev, 2)) / (stdDev * Math.sqrt(2 * Math.PI))
                }],
                borderColor: 'rgba(255, 99, 132, 1)',
                borderWidth: 2,
                pointRadius: 0,
                borderDash: [5, 5]
            }]
        },
        options: {
            scales: {
                x: {
                    type: 'linear',
                    position: 'bottom',
                    title: {
                        display: true,
                        text: 'Value'
                    },
                    ticks: {
                        callback: function(value) {
                            // Calculate z-score for this value
                            const z = (value - mean) / stdDev;
                            // Show both value and z-score
                            return `${formatNumber(value)} (z=${z.toFixed(1)})`;
                        }
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'Probability Density'
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.parsed.x;
                            const z = (value - mean) / stdDev;
                            return [`Value: ${formatNumber(value)}`, `Z-Score: ${z.toFixed(2)}`];
                        }
                    }
                },
                legend: {
                    display: true
                }
            },
            responsive: true,
            maintainAspectRatio: false
        },
        plugins: [{
            id: 'backgroundColoring',
            beforeDraw: (chart) => {
                const {ctx, chartArea, scales} = chart;
                const {left, right, top, bottom} = chartArea;
                
                // Draw colored background areas based on z-scores
                let prevX = scales.x.getPixelForValue(mean + (minZ * stdDev));
                
                for (let i = 0; i < backgroundColors.length; i++) {
                    const z = minZ + (i * step);
                    const x = scales.x.getPixelForValue(mean + (z * stdDev));
                    const nextZ = minZ + ((i+1) * step);
                    const nextX = scales.x.getPixelForValue(mean + (nextZ * stdDev));
                    
                    ctx.fillStyle = backgroundColors[i];
                    ctx.fillRect(x, top, nextX - x, bottom - top);
                    
                    prevX = x;
                }
            }
        }]
    });
}

function createZScoreGauge(zScore) {
    // Clamp z-score to be between -3 and 3
    const clampedZScore = Math.max(-3, Math.min(3, zScore));
    document.getElementById('gaugeValue').textContent = `Z-Score: ${clampedZScore.toFixed(2)}`;
    const color = clampedZScore < 0 ? `rgb(0, ${255 - Math.abs(clampedZScore) * 85}, 0)` : `rgb(${clampedZScore * 85}, 0, 0)`;
    document.getElementById('gaugeValue').style.color = color;
}

// Start the initialization process
initialize();
    </script>
</body>
</html>
